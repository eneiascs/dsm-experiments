/*
 * generated by Xtext 2.11.0
 */
package br.unb.autoexp.validation

import br.unb.autoexp.autoExp.AutoExpPackage
import br.unb.autoexp.autoExp.DependentVariable
import br.unb.autoexp.autoExp.Execution
import br.unb.autoexp.autoExp.Experiment
import br.unb.autoexp.autoExp.Factor
import br.unb.autoexp.autoExp.ResearchHypothesis
import br.unb.autoexp.autoExp.ResearchHypothesisFormula
import br.unb.autoexp.autoExp.Treatment
import br.unb.autoexp.generator.ExperimentalDesignGenerator
import javax.inject.Inject
import org.eclipse.xtext.validation.Check

import static extension java.lang.String.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AutoExpValidator extends AbstractAutoExpValidator {
	public static val ISSUE_CODE_PREFIX = "br.unb.autoexp.";

	public static val HIERARCHY_CYCLE = ISSUE_CODE_PREFIX + "HierarchyCycle";

	public static val INVALID_ENTITY_NAME = ISSUE_CODE_PREFIX + "InvalidEntityName";
	public static val INVALID_ATTRIBUTE_NAME = ISSUE_CODE_PREFIX + "InvalidAttributeName";
	public static val INVALID_PARAMETER_PLACEHOLDER = ISSUE_CODE_PREFIX + "InvalidParameterPlaceholder";
	public static val SAME_TREATMENT_COMPARISON = ISSUE_CODE_PREFIX + "SameTreatmentComparison";
	public static val TREATMENT_FROM_DISTINCT_FACTORS = ISSUE_CODE_PREFIX + "InvalidTreatment";
	public static val SAME_FORMULA = ISSUE_CODE_PREFIX + "SameFormula";
	public static val DEPENDENT_VARIABLE_NEVER_USED = ISSUE_CODE_PREFIX + "DependentVariableNeverUsed"
	public static val FACTOR_NEVER_USED = ISSUE_CODE_PREFIX + "FactorNeverUsed"
	public static val TREATMENT_NEVER_USED = ISSUE_CODE_PREFIX + "TreatmentNeverUsed"
	public static val EXECUTION_NEVER_USED = ISSUE_CODE_PREFIX + "ExecutionNeverUsed"
	public static val INVALID_PARAMETER = ISSUE_CODE_PREFIX + "InvalidParameter"
	public static val UNREGISTERED_DESIGN = ISSUE_CODE_PREFIX + "UnregisteredDesign"

	@Inject extension ExperimentalDesignGenerator

//	@Check
//	def checkUnregisteredDesign(ExperimentalDesign design) {
//			if (design.type.generator===null) {
//
//				error("There is no generators registered for design type '%s'".format(design.type.getName),
//					AutoExpPackage.eINSTANCE.experimentalDesign_Type, AutoExpValidator.UNREGISTERED_DESIGN, design.type.getName)
//			}
//	
//	}


	@Check
	def checkRepeatedHypothesis(ResearchHypothesis hypothesis) {
		val experiment = hypothesis.eContainer as Experiment

		experiment.researchHypotheses.forEach [ hyp |
			if (!hypothesis.name.equals(hyp.name) && hypothesis.formula.depVariable.equals(hyp.formula.depVariable) &&
				hypothesis.formula.treatment1.equals(hyp.formula.treatment1) &&
				hypothesis.formula.operator.typeName.equals(hyp.formula.operator.typeName) &&
				hypothesis.formula.treatment2.equals(hyp.formula.treatment2)) {

				warning("Hyphoteses '%s' and '%s' have the same formula".format(hypothesis.name, hyp.name),
					AutoExpPackage.eINSTANCE.researchHypothesis_Formula, AutoExpValidator.SAME_FORMULA, experiment.name)
			}
		]

	}

	@Check
	def checkSameTreatmentComparison(ResearchHypothesisFormula hyphotesisFormula) {
		if (hyphotesisFormula.treatment1.equals(hyphotesisFormula.treatment2))
			error("Comparison must be done between distinct treatments",
				AutoExpPackage.eINSTANCE.researchHypothesisFormula_Treatment2, SAME_TREATMENT_COMPARISON,
				hyphotesisFormula.treatment2.name)
	}

	@Check
	def checkTreatmentsFromDistinctFactors(ResearchHypothesisFormula hyphotesisFormula) {
		if (!hyphotesisFormula.treatment1.factor.equals(hyphotesisFormula.treatment2.factor))
			error(
				"Treatments '%s' and '%s' do not belong to the same factor".format(hyphotesisFormula.treatment1.name,
					hyphotesisFormula.treatment2.name), AutoExpPackage.eINSTANCE.researchHypothesisFormula_Treatment2,
				TREATMENT_FROM_DISTINCT_FACTORS, hyphotesisFormula.treatment2.name)
	}

	@Check
	def checkDependentVariableNeverUsed(DependentVariable variable) {
		val experiment = variable.eContainer as Experiment
		if (!experiment.researchHypotheses.map[formula.depVariable].contains(variable)) {
			warning("Dependent variable '%s' is never used".format(variable.name),
				AutoExpPackage.eINSTANCE.dependentVariable_Name, AutoExpValidator.DEPENDENT_VARIABLE_NEVER_USED,
				variable.name)
			}
		}

		@Check
		def checkFactorNeverUsed(Factor factor) {
			val experiment = factor.eContainer as Experiment
			if (!experiment.researchHypotheses.map[formula.treatment1.factor].contains(factor) &&
				!experiment.researchHypotheses.map[formula.treatment2.factor].contains(factor)) {
				warning("Factor '%s' is never used".format(factor.name), AutoExpPackage.eINSTANCE.factor_Name,
					AutoExpValidator.FACTOR_NEVER_USED, factor.name)
			}
		}

		@Check
		def checkTreatmentNeverUsed(Treatment treatment) {
			val experiment = treatment.eContainer as Experiment
			if (!experiment.researchHypotheses.map[formula.treatment1].contains(treatment) &&
				!experiment.researchHypotheses.map[formula.treatment2].contains(treatment)) {
				warning("Treatment '%s' is never used".format(treatment.name), AutoExpPackage.eINSTANCE.treatment_Name,
					AutoExpValidator.TREATMENT_NEVER_USED, treatment.name)
			}
		}

		@Check
		def checkExecutionNeverUsed(Execution execution) {
			val experiment = execution.eContainer as Experiment
			if (!experiment.researchHypotheses.map[formula.treatment1.execution].contains(execution) &&
				!experiment.researchHypotheses.map[formula.treatment2.execution].contains(execution)) {
				warning("Execution '%s' is never used".format(execution.name), AutoExpPackage.eINSTANCE.execution_Name,
					AutoExpValidator.EXECUTION_NEVER_USED, execution.name)
			}
		}

		@Check
		def checkInvalidParameter(Execution execution) {
			val experiment = execution.eContainer as Experiment
			
			experiment.designExecutions.filter[execution.name.equals(name)].forEach [ exec |
				exec.invalidParameters.forEach [ parameter,attribute |
					
					
					val att=switch attribute{
						case "cmd": AutoExpPackage.eINSTANCE.execution_Cmd
						case "result": AutoExpPackage.eINSTANCE.execution_Result
					}
					error("Parameter '%s' cannot be resolved".format(parameter), att,
						AutoExpValidator.INVALID_PARAMETER, parameter)
				]

			]

		}

//		@Check
//		def checkInvalidParameterResult(Execution execution) {
//			val experiment = execution.eContainer as Experiment
//
//			experiment.designExecutions.forEach [ exec |
//				exec.files.filter[generated].head.path.parameters.forEach [ parameter |
//					if (exec.files.filter[generated].head.name.equals(execution.result.name))
//						error("Parameter '%s' cannot be resolved".format(parameter),
//							AutoExpPackage.eINSTANCE.execution_Result, AutoExpValidator.INVALID_PARAMETER, parameter)
//				]
//
//			]
//
//		}

	}
	