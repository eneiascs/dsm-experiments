/*
 * generated by Xtext 2.11.0
 */
package br.unb.autoexp.validation

import br.unb.autoexp.autoExp.AutoExpPackage
import br.unb.autoexp.autoExp.DependentVariable
import br.unb.autoexp.autoExp.Execution
import br.unb.autoexp.autoExp.Experiment
import br.unb.autoexp.autoExp.ExperimentalObject
import br.unb.autoexp.autoExp.Factor
import br.unb.autoexp.autoExp.ResearchHypothesis
import br.unb.autoexp.autoExp.ResearchHypothesisFormula
import br.unb.autoexp.autoExp.Treatment
import br.unb.autoexp.generator.ExperimentalDesignGenerator
import javax.inject.Inject
import org.eclipse.xtext.validation.Check

import static extension java.lang.String.*
import br.unb.autoexp.autoExp.ScaleType
import java.math.BigDecimal

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AutoExpValidator extends AbstractAutoExpValidator {
	public static val ISSUE_CODE_PREFIX = "br.unb.autoexp.";

	public static val HIERARCHY_CYCLE = ISSUE_CODE_PREFIX + "HierarchyCycle";

	public static val INVALID_ENTITY_NAME = ISSUE_CODE_PREFIX + "InvalidEntityName";
	public static val INVALID_ATTRIBUTE_NAME = ISSUE_CODE_PREFIX + "InvalidAttributeName";
	public static val INVALID_PARAMETER_PLACEHOLDER = ISSUE_CODE_PREFIX + "InvalidParameterPlaceholder";
	public static val SAME_TREATMENT_COMPARISON = ISSUE_CODE_PREFIX + "SameTreatmentComparison";
	public static val TREATMENT_FROM_DISTINCT_FACTORS = ISSUE_CODE_PREFIX + "InvalidTreatment";
	public static val SAME_FORMULA = ISSUE_CODE_PREFIX + "SameFormula";
	public static val DEPENDENT_VARIABLE_NEVER_USED = ISSUE_CODE_PREFIX + "DependentVariableNeverUsed"
	public static val FACTOR_NEVER_USED = ISSUE_CODE_PREFIX + "FactorNeverUsed"
	public static val TREATMENT_NEVER_USED = ISSUE_CODE_PREFIX + "TreatmentNeverUsed"
	public static val EXECUTION_NEVER_USED = ISSUE_CODE_PREFIX + "ExecutionNeverUsed"
	public static val INVALID_PARAMETER = ISSUE_CODE_PREFIX + "InvalidParameter"
	public static val UNREGISTERED_DESIGN = ISSUE_CODE_PREFIX + "UnregisteredDesign"
	public static val NUMERIC_VALUE_MISSING = ISSUE_CODE_PREFIX + "NumericValueMissing"
	@Inject extension ExperimentalDesignGenerator

	@Check
	def checkRepeatedHypothesis(ResearchHypothesis hypothesis) {
		val experiment = hypothesis.eContainer as Experiment

		experiment.researchHypotheses.forEach [ hyp |
			if (!hypothesis.name.equals(hyp.name) && hypothesis.formula.depVariable.equals(hyp.formula.depVariable) &&
				hypothesis.formula.treatment1.equals(hyp.formula.treatment1) &&
				hypothesis.formula.operator.typeName.equals(hyp.formula.operator.typeName) &&
				hypothesis.formula.treatment2.equals(hyp.formula.treatment2)) {

				warning("Hyphoteses '%s' and '%s' have the same formula".format(hypothesis.name, hyp.name),
					AutoExpPackage.eINSTANCE.researchHypothesis_Formula, AutoExpValidator.SAME_FORMULA, experiment.name)
			}
		]

	}

	@Check
	def checkSameTreatmentComparison(ResearchHypothesisFormula hyphotesisFormula) {
		if (hyphotesisFormula.treatment1.equals(hyphotesisFormula.treatment2))
			error("Comparison must be done between distinct treatments",
				AutoExpPackage.eINSTANCE.researchHypothesisFormula_Treatment2, SAME_TREATMENT_COMPARISON,
				hyphotesisFormula.treatment2.name)
	}

	@Check
	def checkTreatmentsFromDistinctFactors(ResearchHypothesisFormula hyphotesisFormula) {
		if (!hyphotesisFormula.treatment1.factor.equals(hyphotesisFormula.treatment2.factor))
			error(
				"Treatments '%s' and '%s' do not belong to the same factor".format(hyphotesisFormula.treatment1.name,
					hyphotesisFormula.treatment2.name), AutoExpPackage.eINSTANCE.researchHypothesisFormula_Treatment2,
				TREATMENT_FROM_DISTINCT_FACTORS, hyphotesisFormula.treatment2.name)
	}

	@Check
	def checkDependentVariableNeverUsed(DependentVariable variable) {
		val experiment = variable.eContainer as Experiment
		if (!experiment.researchHypotheses.map[formula.depVariable].contains(variable)) {
			warning("Dependent variable '%s' is never used".format(variable.name),
				AutoExpPackage.eINSTANCE.dependentVariable_Name, AutoExpValidator.DEPENDENT_VARIABLE_NEVER_USED,
				variable.name)
		}
	}

	@Check
	def checkFactorNeverUsed(Factor factor) {
		val experiment = factor.eContainer as Experiment
		if (!experiment.researchHypotheses.map[formula.treatment1.factor].contains(factor) &&
			!experiment.researchHypotheses.map[formula.treatment2.factor].contains(factor)) {
			warning("Factor '%s' is never used".format(factor.name), AutoExpPackage.eINSTANCE.factor_Name,
				AutoExpValidator.FACTOR_NEVER_USED, factor.name)
		}
	}

	@Check
	def checkTreatmentNeverUsed(Treatment treatment) {
		val experiment = treatment.eContainer as Experiment
		if (!experiment.researchHypotheses.map[formula.treatment1].contains(treatment) &&
			!experiment.researchHypotheses.map[formula.treatment2].contains(treatment)) {
			warning("Treatment '%s' is never used".format(treatment.name), AutoExpPackage.eINSTANCE.treatment_Name,
				AutoExpValidator.TREATMENT_NEVER_USED, treatment.name)
		}
	}

	@Check
	def checkExecutionNeverUsed(Execution execution) {
		if (execution.eContainer instanceof Experiment) {
			val experiment = execution.eContainer as Experiment
			if (!experiment.researchHypotheses.map[formula.treatment1.execution].contains(execution) &&
				!experiment.researchHypotheses.map[formula.treatment2.execution].contains(execution)) {
				warning("Execution '%s' is never used".format(execution.name), AutoExpPackage.eINSTANCE.execution_Name,
					AutoExpValidator.EXECUTION_NEVER_USED, execution.name)
			}

		}
	}

	@Check
	def checkInvalidParameter(Execution execution) {
		if (execution.eContainer instanceof Experiment) {
			val experiment = execution.eContainer as Experiment

			experiment.designExecutions.filter[execution.name.equals(name)].forEach [ exec |
				exec.invalidParameters.forEach [ parameter, attribute |

					val att = switch attribute {
						case "cmd": AutoExpPackage.eINSTANCE.execution_Cmd
						case "result": AutoExpPackage.eINSTANCE.execution_Result
					}
					error("Parameter '%s' cannot be resolved".format(parameter), att,
						AutoExpValidator.INVALID_PARAMETER, parameter)
				]

			]

		}

	}

	@Check
	def checkNumericScaleTypeWithoutNumericValue(ExperimentalObject object) {
		val experiment = object.eContainer as Experiment

		if (experiment.objectsScaleType.equals(ScaleType.ABSOLUTE) ||
			experiment.objectsScaleType.equals(ScaleType.LOGARITHMIC)) {
			
			try {
				
				new BigDecimal(object.value)
			} catch (Exception e) {
			
				error("Scale type '%s' requires a numeric value.".format(experiment.objectsScaleType.getName),
					AutoExpPackage.eINSTANCE.experimentalObject_Name, AutoExpValidator.NUMERIC_VALUE_MISSING,
					object.name)

				}
			}
		}
	}
	